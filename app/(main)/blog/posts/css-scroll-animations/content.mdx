---
title: CSS Scroll-Driven Animations
description:
  Scroll-driven animations is an extremely exciting feature that is coming to
  CSS. Join me as we explore how to use scroll-driven animations to create
  performant and well polished user experiences.
date: "2023-09-29"
---

import CodeBlock from "../../components/CodeBlock"
import Demo from "../../components/Demo"
import BasicScroll from "./BasicScroll"
import BasicView from "./BasicView"

In a recent project at work, I started exploring CSS scroll-driven animations to
transition elements in a sticky header between a larger and smaller size. After
just a couple hours of exploration I had a working prototype using scroll
animations to replace the much less reliable and smooth JavaScript based
animation.

Having just scratched the surface of what is possible with scroll-driven
animations, I knew a blog post was in order to show off some of the incredible
features of scroll-driven animations.

> [!WARN Experimental features ahead!]  
> CSS scroll-driven animations are still experimental. At the time of writing,
> support for scroll-driven animations is primarily in Chromium with Firefox
> supporting them behind a flag. Safari unfortunately does not support them at
> all. For more details, checkout the
> [MDN compatibility table](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline#browser_compatibility).

## What are animation timelines?

Before diving into scroll-driven animations, we first need to understand what
[animation timelines](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline)
are. Historically, the only animation timeline that existed was the
[document timeline](https://developer.mozilla.org/en-US/docs/Web/API/DocumentTimeline)
which will start incrementing when the page loads. As long as the page remains
open, the document timeline will continue to increment. We can observe this by
logging the `document.timeline` variable in our console.

```javascript
console.log(document.timeline) // { currentTime: 62199.911, duration: null }
```

When you apply animations to elements, they use the document timeline to track
the progress of the animation including any delays before starting the
animation, and then the duration of the animation itself.

Because scroll-driven animations are based on scroll progress and not time
durations, the document timeline doesn't make sense when starting to think about
animating elements based on scroll position. This is why scroll-driven
animations introduced the `animation-timeline` property which allows us to
target two new types of animation timelines that will be used to create
scroll-driven animations.

## Using the Scroll Timeline

Enough talk, let's see an example! We'll start with a rather simple example
showing a blue box that rotates as it's container scrolls. Try scrolling the
container below to see it rotate!

<Demo>
  <BasicScroll />
</Demo>

Let's take a look at the code for this simple animation. The HTML structure is
quite simple, just three nested `div`s.

```html
<div className="container">
  <div className="scroll-area">
    <div className="box" />
  </div>
</div>
```

For the CSS, we have some fairly typical code to define a set of keyframes for
our animation, set up our container and scroll area, and then style and position
our box in the center of the container. The highlighted lines are certainly the
most interesting, as that's where we define our animation.

```css {20-21}
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.container {
  height: 480px;
  overflow-y: scroll;
}

.scroll-area {
  height: 1200px;
}

.box {
  animation: spin linear;
  animation-timeline: scroll();
  aspect-ratio: 1;
  left: calc(50% - 60px);
  position: relative;
  top: calc(50% - 60px);
  width: 120px;
}
```

We specify the animation just like we would with any other CSS animation by
referencing our set of keyframes (`spin`), and an easing function (`linear`).
You may noticed that we haven't added an animation duration, which again makes
sense since our animation is tied to scroll progress rather than a
time-duration. Finally, the most important part is specifying
`animation-timeline: scroll()` which tells the browser that our animation should
be based on the scroll progress of the nearest scroll ancestor.

Just like that, we've built our first scroll-driven animation!

> [!ERROR Firefox bug]  
> To make this work properly in Firefox, we need to add
> `animation-duration: 1ms` to our styles. The exact value value doesn't
> actually matter, but Firefox needs the property for the animation to work.
> Hopefully this will be fixed as Firefox support for scroll-driven animations
> continues to improve.

## TODO

That previous example was fun, but it's not all that useful to just make a box
spin as the user scrolls down the page. There are plenty of use cases though
where you might want to create animations using the scroll timeline, such as:

- Adding a reading progress indicator for a blog post.
-

## Using the View Timeline

View Timeline animations are very similar to Scroll Timeline animations, but
instead of tracking the progress of the scroll container, view animations track
the entry/exit progress of an element within it's parent. Some examples of this
might include:

- Adding a shadow or similar styling to a sticky header as you begin to scroll.
-

Let's go ahead and implement that first idea of adding styling to a sticky
header as you scroll the page. Before we do, here is the kind of code you might
be used to for a task like this:

```javascript
let [isScrolled, setIsScrolled] = useState(false)

useEffect(() => {
  function onScroll() {
    setIsScrolled(window.scrollY > 0)
  }

  onScroll()
  window.addEventListener("scroll", onScroll, { passive: true })
  return () => window.removeEventListener("scroll", onScroll, { passive: true })
}, [])

return <header className={isScrolled ? "shadow-lg" : ""}></header>
```

In the code above, we are using some state to track whether the window has been
scrolled so we can conditionally apply styles. This works okay, but scroll
listeners have

<Demo tight>
  <BasicView />
</Demo>

Once again, the HTML for our demo is quite simple. We have a parent element
which will be our scroll container, our header, and the content. The only
special element is a "sentinel" which we will use to track the view transition
progress.

```html
<div class="parent">
  <div class="sentinel" />
  <header>Lorem AI</header>
  <main>...</main>
</div>
```

Now, the CSS for this is a bit complex, but I've highlighted the most important
bits in the code block below. In addition to using View Timelines, we have to
reach for another feature of CSS scroll-driven animations: `timeline-scope`.

```css {16,22,26-29}
@keyframes header {
  from {
    backdrop-filter: blur(0);
    background: transparent;
  }
  to {
    backdrop-filter: blur(8px);
    background: rgb(30 41 59 / 0.75);
  }
}

.parent {
  height: 320px;
  overflow-y: scroll;
  position: relative;
  timeline-scope: --tl;
}

.sentinel {
  height: 80px;
  position: absolute;
  view-timeline: --tl;
}

header {
  animate: header linear forwards;
  animation-duration: 1ms; /* Firefox requires this to apply the animation */
  animation-range: exit;
  animation-timeline: --tl;
  position: sticky;
  top: 0;
  width: 100%;
}
```
