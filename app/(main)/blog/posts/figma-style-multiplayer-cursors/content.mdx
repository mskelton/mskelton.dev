---
title: Figma Style Multiplayer Cursors
description:
date: "2023-11-26"
---

Real-time applications have always fascinated me. The idea that you can connect
people from all over the world in a single web application to chat, edit files,
or play games with near instant feedback is simply amazing. Having very little
experience with what goes into building real-time applications I was interesting
in re-building a key feature of collaboration within Figma: multiplayer cursors.

While this feature may seem relatively simple given the result is just some
cursors that move around on the screen, the implementation requires a
non-trivial amount of code to build. To get started with building our
application, let's first outline the main requirements for the project:

- Low-latency updates between connected users
- Cursors are added when new users connect to the application
- Cursors are removed when users disconnect from the application
- When a user connects, they immediately see all the users who are currently
  connected
- The client automatically reconnects to the server if the connection is
  unexpectedly closed

A very naive approach to this problem would be to use a polling technique where
the client periodically sends it's cursor position to the server and receives
the positions of other connected users. This would result in a great deal of lag
due to the polling delay as well as the time required for each HTTP request.
[WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
are much better suited for this application, but they are more complex to
implement.

Before we can implement WebSockets in our application, we probably should build
the core application itself! We'll get back to WebSockets later in this post, as
that is certainly the most interesting part of this build, but let's get some of
the basics knocked out first.

## Scaffolding the application

This application is very simple, but I'm building it in a way that could fit
easily into an existing React application. Nothing in this is React specific, so
everything could be done with another framework or vanilla HTML and JavaScript.
Checkout the [further reading](#further-reading) section

```javascript
function App() {
  return (
    <>
      <Cursors />
      <Tracker />
    </>
  )
}
```

## Introduction to WebSockets

WebSockets are persistent HTTP connections that allow bi-directional
communication between the client and server. By maintaining an open connection,
they are able to achieve very low-latency which is exactly what we need given
the high number of messages being passed between clients as users move their
cursors and send position updates to other clients.

Establishing a WebSocket connection is a bit different from a typical HTTP
connection, as shown in this diagram:

![WebSocket lifecycle](websocket-diagram.png)

Creating the connection starts like any other HTTP request. However, when the
server receives the request, it will respond with a status code of
`101 Switching Protocols` and return two response headers to indicate to the
client that the request is being upgraded to a WebSocket connection.

```http
Connection: Upgrade
Upgrade: websocket
```

After the client has successfully received this response, the WebSocket
connection has been made and messages can now be passed from the client to the
server or vice versa.

## Further reading

- [GitHub repo - React version](https://github.com/mskelton/cursed)
