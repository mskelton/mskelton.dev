---
title: Figma Style Multiplayer Cursors
description:
date: "2023-11-26"
---

Real-time applications have always fascinated me. The idea that you can connect
people from all over the world in a single web application to chat, edit files,
or play games with near instant feedback is simply amazing. Having very little
experience with what goes into building real-time applications I was interesting
in re-building a key feature of collaboration within Figma: multiplayer cursors.

While this feature may seem relatively simple given the result is just some
cursors that move around on the screen, the implementation requires a
non-trivial amount of code to build. To get started with building our
application, let's first outline the main requirements for the project:

- Low-latency updates between connected users
- Cursors are added when new users connect to the application
- Cursors are removed when users disconnect from the application
- When a user connects, they immediately see all the users who are currently
  connected
- The client automatically reconnects to the server if the connection is
  unexpectedly closed

A very naive approach to this problem would be to use a polling technique where
the client periodically sends it's cursor position to the server and receives
the positions of other connected users. This would result in a great deal of lag
due to the polling delay as well as the time required for each HTTP request.
[WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
are much better suited for this application, but they are more complex to
implement.

Before we can implement WebSockets in our application, we probably should build
the core application itself! We'll get back to WebSockets later in this post, as
that is certainly the most interesting part of this build, but let's get some of
the basics knocked out first.

## Scaffolding the application

This application is very simple, but I'm building it in a way that could fit
easily into an existing React application. Nothing in this is React specific, so
everything could be done with another framework or vanilla HTML and JavaScript.
Checkout the [further reading](#further-reading) section for links to the source
code on GitHub for both this React version as well as other frameworks. The
frameworks and tools I'm using for this application include:

- [Tailwind CSS](https://tailwindcss.com) for styling
- [Rsbuild](https://rsbuild.dev) for bundling
- [Bun](https://bun.sh) as the server

Starting at the root of the application, there are two primary components we
need to build: `Cursors` and `Tracker`. The `Cursors` component will be
responsible for showing the cursors of **other** users that are connected and
the `Tracker` component will be responsible for sending updates from **us** to
other users.

```tsx
function App() {
  return (
    <>
      <Cursors />
      <Tracker />
    </>
  )
}
```

Let's start with the implementation of `Tracker` as it's the simpler of the two.
This component will need to listen to changes to cursor position and publish
that information to the server so other users can receive the updated cursor
position. We can do this by registering a
[`mousemove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event)
listener inside of a `useEffect` hook.

```ts
export function Tracker() {
  useEffect(() => {
    function handleMove(event: MouseEvent) {
      console.log(`X:${event.clientX}, Y:${event.clientY}`)
    }

    window.addEventListener("mousemove", handleMove)

    return () => {
      window.removeEventListener("mousemove", handleMove)
    }
  }, [])

  return null
}
```

Now that we are listening to `mousemove` events, you should see logs in the
browser console every time that you move your cursor in the app. This isn't that
useful since that only shows up for us, but it's a great first step. We'll fill
in the rest later in this post after we setup our WebSocket so we can publish
our cursor position to other users.

### Supporting touch devices

Before moving on, let's take a moment to consider mobile devices. While this
code works great for a laptop or desktop computer, if you try to run it on a
phone or tablet, you'll notice that it doesn't print anything to the console.
Mobile devices don't actually fire `mousemove` (or related events) when you
touch or drag your finger around the screen. This is because mouse and touch
interactions are fundamentally different, so they cannot both be represented by
the same event object.

One of the key differences between mouse and touch events is that touch events
can have more than one set of coordinates given that you can touch the screen
with multiple fingers at the same time. You can access each set of coordinates
via the `event.touches` property which is a list of individual touches each of
which contain their coordinates.

For our application, we don't _really_ care if the user is touching the screen
with one finger, or three fingers, in both cases we only want to show a single
cursor to other users. So while there may be more than one touch in
`event.touches`, we can simply use the first touch in the list to track cursor
(or I suppose more properly finger) movement.

```ts
useEffect(() => {
  function handleMove(event: MouseEvent | TouchEvent) {
    const source = "touches" in event ? event.touches[0] : event

    console.log(`X:${source.clientX}, Y:${source.clientY}`)
  }

  window.addEventListener("mousemove", handleMove)
  window.addEventListener("touchmove", handleTouch)

  return () => {
    window.removeEventListener("mousemove", handleMove)
    window.removeEventListener("touchmove", handleTouch)
  }
}, [socket])
```

## Introduction to WebSockets

WebSockets are persistent HTTP connections that allow bi-directional
communication between the client and server. By maintaining an open connection,
they are able to achieve very low-latency which is exactly what we need given
the high number of messages being passed between clients as users move their
cursors and send position updates to other clients.

Establishing a WebSocket connection is a bit different from a typical HTTP
connection, as shown in this diagram:

![WebSocket lifecycle](websocket-diagram.png)

Creating the connection starts like any other HTTP request. However, when the
server receives the request, it will respond with a status code of
`101 Switching Protocols` and return two response headers to indicate to the
client that the request is being upgraded to a WebSocket connection.

```http
Connection: Upgrade
Upgrade: websocket
```

After the client has successfully received this response, the WebSocket
connection has been made and messages can now be passed from the client to the
server or vice versa.

## Further reading

- [GitHub repo - React version](https://github.com/mskelton/cursed)
